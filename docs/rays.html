

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Rays &mdash; batoid 0.2.0rc1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Surfaces" href="surfaces.html" />
    <link rel="prev" title="Overview" href="overview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> batoid
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Rays</a></li>
<li class="toctree-l1"><a class="reference internal" href="surfaces.html">Surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="optic.html">Optics</a></li>
<li class="toctree-l1"><a class="reference internal" href="coords.html">Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="obscurations.html">Obscurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="media.html">Media</a></li>
<li class="toctree-l1"><a class="reference internal" href="coatings.html">Coatings</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lattice.html">Lattices</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">batoid</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Rays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/rays.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rays">
<h1>Rays<a class="headerlink" href="#rays" title="Permalink to this headline">¶</a></h1>
<p>The most fundamental type in batoid is the <a class="reference internal" href="#batoid.RayVector" title="batoid.RayVector"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RayVector</span></code></a>.  This class represents
a collection of geometric rays.  These rays can be generated, traced through
optical systems, and then interrogated to provide insight into PSFs,
aberrations, vignetting, and more.</p>
<dl class="py class">
<dt id="batoid.RayVector">
<em class="property">class </em><code class="sig-prename descclassname">batoid.</code><code class="sig-name descname">RayVector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">vz</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">vignetted</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">failed</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">coordSys</span><span class="o">=</span><span class="default_value">CoordSys(array([0., 0., 0.]), array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]))</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RayVector from 1d parameter arrays.  Always makes a copy
of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x, y, z</strong> (<em>ndarray of float, shape (n,)</em>) – Positions of rays in meters.</p></li>
<li><p><strong>vx, vy, vz</strong> (<em>ndarray of float, shape (n,)</em>) – Velocities of rays in units of the speed of light in vacuum.</p></li>
<li><p><strong>t</strong> (<em>ndarray of float, shape (n,)</em>) – Reference times (divided by the speed of light in vacuum) in units
of meters.</p></li>
<li><p><strong>wavelength</strong> (<em>ndarray of float, shape (n,)</em>) – Vacuum wavelengths in meters.</p></li>
<li><p><strong>flux</strong> (<em>ndarray of float, shape (n,)</em>) – Fluxes in arbitrary units.</p></li>
<li><p><strong>vignetted</strong> (<em>ndarray of bool, shape (n,)</em>) – True where rays have been vignetted.</p></li>
<li><p><strong>coordSys</strong> (<em>CoordSys</em>) – Coordinate system in which this ray is expressed.  Default: the
global coordinate system.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="batoid.RayVector.positionAtTime">
<code class="sig-name descname">positionAtTime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.positionAtTime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.positionAtTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the positions of the rays at a given time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em>) – Time (over vacuum speed of light; in meters).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>ndarray of float, shape (n, 3)</em> – Positions in meters.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.propagate">
<code class="sig-name descname">propagate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.propagate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate this RayVector to given time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em>) – Time (over vacuum speed of light; in meters).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>RayVector</em> – Reference to self, no copy is made.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.phase">
<code class="sig-name descname">phase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane wave phases at given position and time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>ndarray of float, shape (3,)</em>) – Position in meters at which to compute phase</p></li>
<li><p><strong>t</strong> (<em>float</em>) – Time (over vacuum speed of light; in meters).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>ndarray of float, shape(n,)</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.amplitude">
<code class="sig-name descname">amplitude</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.amplitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (scalar) complex electric-field amplitudes at given
position and time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>ndarray of float, shape (3,)</em>) – Position in meters.</p></li>
<li><p><strong>t</strong> (<em>float</em>) – Time (over vacuum speed of light; in meters).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>ndarray of complex, shape (n,)</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.sumAmplitude">
<code class="sig-name descname">sumAmplitude</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">ignoreVignetted</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.sumAmplitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.sumAmplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sum of (scalar) complex electric-field amplitudes of
all rays at given position and time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>ndarray of float, shape (3,)</em>) – Position in meters.</p></li>
<li><p><strong>t</strong> (<em>float</em>) – Time (over vacuum speed of light; in meters).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>complex</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.asGrid">
<em class="property">classmethod </em><code class="sig-name descname">asGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optic</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backDist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">medium</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stopSurface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dirCos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">'postel'</span></em>, <em class="sig-param"><span class="n">nx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ny</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ly</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nrandom</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.asGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.asGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RayVector on a parallelogram shaped region.</p>
<p>This function will often be used to create a grid of rays on a square
grid, but is flexible enough to also create grids on an arbitrary
parallelogram, or even randomly distributed across an arbitrary
parallelogram-shaped region.</p>
<p>The algorithm starts by placing rays on the “stop” surface, and then
backing them up such that they are in front of any surfaces of the
optic they’re intended to trace.</p>
<p>The stop surface of most large telescopes is the plane perpendicular to
the optic axis and flush with the rim of the primary mirror.  This
plane is usually also the entrance pupil since there are no earlier
refractive or reflective surfaces.  However, since this plane is a bit
difficult to locate automatically, the default stop surface in batoid
is the global x-y plane.</p>
<p>If a telescope has a stopSurface attribute in its yaml file, then this
is usually a good choice to use in this function.  Using a curved
surface for the stop surface is allowed, but is usually a bad idea as
this may lead to a non-uniformly illuminated pupil and is inconsistent
with, say, an incoming uniform spherical wave or uniform plane wave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optic</strong> (<a class="reference internal" href="optic.html#batoid.Optic" title="batoid.Optic"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Optic</span></code></a>, optional) – If present, then try to extract values for <code class="docutils literal notranslate"><span class="pre">backDist</span></code>,
<code class="docutils literal notranslate"><span class="pre">medium</span></code>, <code class="docutils literal notranslate"><span class="pre">stopSurface</span></code>, and <code class="docutils literal notranslate"><span class="pre">lx</span></code> from the Optic.  Note that
values explicitly passed to <a class="reference internal" href="#batoid.RayVector.asGrid" title="batoid.RayVector.asGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">asGrid</span></code></a> as keyword arguments override
those extracted from <code class="docutils literal notranslate"><span class="pre">optic</span></code>.</p></li>
<li><p><strong>backDist</strong> (<em>float, optional</em>) – Map rays backwards from the stop surface to the plane that is
perpendicular to the rays and <code class="docutils literal notranslate"><span class="pre">backDist</span></code> meters from the point
(0, 0, z(0,0)) on the stop surface.  This should generally be set
large enough that any obscurations or phantom surfaces occuring
before the stop surface are now “in front” of the ray.  If this
keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then
infer a value from <code class="docutils literal notranslate"><span class="pre">optic.backDist</span></code>.  If both this keyword and
<code class="docutils literal notranslate"><span class="pre">optic</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of 40 meters, which
should be sufficiently large for foreseeable telescopes.</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="media.html#batoid.Medium" title="batoid.Medium"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Medium</span></code></a>, optional) – Initial medium of each ray.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.inMedium</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of vacuum.</p></li>
<li><p><strong>stopSurface</strong> (<em>batoid.Interface, optional</em>) – Surface defining the system stop.  If this keyword is set to
<code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.stopSurface</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default <code class="docutils literal notranslate"><span class="pre">Interface(Plane())</span></code>, which is the
global x-y plane.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Vacuum wavelength of rays in meters.</p></li>
<li><p><strong>source</strong> (<em>None or ndarray of float, shape (3,), optional</em>) – Where rays originate.  If None, then rays originate an infinite
distance away, in which case the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg must also be
specified to set the direction of ray propagation.  If an ndarray,
then the rays originate from this point in global coordinates and
the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg is ignored.</p></li>
<li><p><strong>dirCos</strong> (<em>ndarray of float, shape (3,), optional</em>) – If source is None, then this indicates the initial direction of
propagation of the rays.  If source is not None, then this is
ignored.  Also see <code class="docutils literal notranslate"><span class="pre">theta_x</span></code>, <code class="docutils literal notranslate"><span class="pre">theta_y</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>theta_x, theta_y</strong> (<em>float, optional</em>) – Field angle in radians.  If source is None, then this indicates the
initial direction of propagation of the rays.  If source is not
None, then this is ignored.  Uses <a class="reference internal" href="coords.html#batoid.utils.fieldToDirCos" title="batoid.utils.fieldToDirCos"><code class="xref any py py-func docutils literal notranslate"><span class="pre">utils.fieldToDirCos</span></code></a> to convert
to direction cosines.  Also see <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>projection</strong> (<em>{‘postel’, ‘zemax’, ‘gnomonic’, ‘stereographic’, ‘lambert’, ‘orthographic’}, optional</em>) – Projection used to convert field angle to direction cosines.</p></li>
<li><p><strong>nx, ny</strong> (<em>int, optional</em>) – Number of rays on each side of grid.</p></li>
<li><p><strong>dx, dy</strong> (<em>float or (2,) array of float, optional</em>) – Separation in meters between adjacent rays in grid.  If scalars,
then the separations are exactly along the x and y directions.  If
arrays, then these are interpretted as the primitive vectors for
the first and second dimensions of the grid.  If only dx is
explicitly specified, then dy will be inferred as a 90-degree
rotation from dx with the same length as dx.</p></li>
<li><p><strong>lx, ly</strong> (<em>float or (2,) array of float, optional</em>) – Length of each side of ray grid.  If scalars, then these are
measured along the x and y directions.  If arrays, then these also
indicate the primitive vectors orientation of the grid.  If only
lx is specified, then ly will be inferred as a 90-degree rotation
from lx with the same length as lx.  If lx is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then first
infer a value from <code class="docutils literal notranslate"><span class="pre">nx</span></code> and <code class="docutils literal notranslate"><span class="pre">dx</span></code>, and if that doesn’t work,
infer a value from <code class="docutils literal notranslate"><span class="pre">optic.pupilSize</span></code>.</p></li>
<li><p><strong>flux</strong> (<em>float, optional</em>) – Flux to assign each ray.  Default is 1.0.</p></li>
<li><p><strong>nrandom</strong> (<em>None or int, optional</em>) – If not None, then uniformly sample this many rays from
parallelogram region instead of sampling on a regular grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.asPolar">
<em class="property">classmethod </em><code class="sig-name descname">asPolar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optic</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backDist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">medium</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stopSurface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inner</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dirCos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">'postel'</span></em>, <em class="sig-param"><span class="n">nrad</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">naz</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nrandom</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.asPolar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.asPolar" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RayVector on an annular region using a hexapolar grid.</p>
<p>This function can be used to regularly sample the entrance pupil of a
telescope using polar symmetry (really, hexagonal symmetry).  Rings of
different radii are used, with the number of samples on each ring
restricted to a multiple of 6 (with the exception of a potential
central “ring” of radius 0, which is only ever sampled once).  This may
be more efficient than using a square grid since more of the rays
generated may avoid vignetting.</p>
<p>This function is also used to generate rays uniformly randomly sampled
from a given annular region.</p>
<p>The algorithm used here starts by placing rays on the “stop” surface,
and then backing them up such that they are in front of any surfaces of
the optic they’re intended to trace.</p>
<p>The stop surface of most large telescopes is the plane perpendicular to
the optic axis and flush with the rim of the primary mirror.  This
plane is usually also the entrance pupil since there are no earlier
refractive or reflective surfaces.  However, since this plane is a bit
difficult to locate automatically, the default stop surface in batoid
is the global x-y plane.</p>
<p>If a telescope has a stopSurface attribute in its yaml file, then this
is usually a good choice to use in this function.  Using a curved
surface for the stop surface is allowed, but is usually a bad idea as
this may lead to a non-uniformly illuminated pupil and is inconsistent
with, say, an incoming uniform spherical wave or uniform plane wave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optic</strong> (<a class="reference internal" href="optic.html#batoid.Optic" title="batoid.Optic"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Optic</span></code></a>, optional) – If present, then try to extract values for <code class="docutils literal notranslate"><span class="pre">backDist</span></code>,
<code class="docutils literal notranslate"><span class="pre">medium</span></code>, <code class="docutils literal notranslate"><span class="pre">stopSurface</span></code>, and <code class="docutils literal notranslate"><span class="pre">outer</span></code> from the Optic.  Note
that values explicitly passed to <a class="reference internal" href="#batoid.RayVector.asPolar" title="batoid.RayVector.asPolar"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">asPolar</span></code></a> as keyword arguments
override those extracted from <code class="docutils literal notranslate"><span class="pre">optic</span></code>.</p></li>
<li><p><strong>backDist</strong> (<em>float, optional</em>) – Map rays backwards from the stop surface to the plane that is
perpendicular to the ray and <code class="docutils literal notranslate"><span class="pre">backDist</span></code> meters from the point
(0, 0, z(0,0)) on the stop surface.  This should generally be set
large enough that any obscurations or phantom surfaces occuring
before the stop surface are now “in front” of the ray.  If this
keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then
infer a value from <code class="docutils literal notranslate"><span class="pre">optic.backDist</span></code>.  If both this keyword and
<code class="docutils literal notranslate"><span class="pre">optic</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of 40 meters, which
should be sufficiently large for foreseeable telescopes.</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="media.html#batoid.Medium" title="batoid.Medium"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Medium</span></code></a>, optional) – Initial medium of each ray.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.inMedium</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of vacuum.</p></li>
<li><p><strong>stopSurface</strong> (<em>batoid.Interface, optional</em>) – Surface defining the system stop.  If this keyword is set to
<code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.stopSurface</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default <code class="docutils literal notranslate"><span class="pre">Interface(Plane())</span></code>, which is the
global x-y plane.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Vacuum wavelength of rays in meters.</p></li>
<li><p><strong>outer</strong> (<em>float</em>) – Outer radius of annulus in meters.</p></li>
<li><p><strong>inner</strong> (<em>float, optional</em>) – Inner radius of annulus in meters.  Default is 0.0.</p></li>
<li><p><strong>source</strong> (<em>None or ndarray of float, shape (3,), optional</em>) – Where rays originate.  If None, then rays originate an infinite
distance away, in which case the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg must also be
specified to set the direction of ray propagation.  If an ndarray,
then the rays originate from this point in global coordinates and
the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg is ignored.</p></li>
<li><p><strong>dirCos</strong> (<em>ndarray of float, shape (3,), optional</em>) – If source is None, then this indicates the initial direction of
propagation of the rays.  If source is not None, then this is
ignored.  Also see <code class="docutils literal notranslate"><span class="pre">theta_x</span></code>, <code class="docutils literal notranslate"><span class="pre">theta_y</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>theta_x, theta_y</strong> (<em>float, optional</em>) – Field angle in radians.  If source is None, then this indicates the
initial direction of propagation of the rays.  If source is not
None, then this is ignored.  Uses <a class="reference internal" href="coords.html#batoid.utils.fieldToDirCos" title="batoid.utils.fieldToDirCos"><code class="xref any py py-func docutils literal notranslate"><span class="pre">utils.fieldToDirCos</span></code></a> to convert
to direction cosines.  Also see <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>projection</strong> (<em>{‘postel’, ‘zemax’, ‘gnomonic’, ‘stereographic’, ‘lambert’, ‘orthographic’}, optional</em>) – Projection used to convert field angle to direction cosines.</p></li>
<li><p><strong>nrad</strong> (<em>int</em>) – Number of radii on which create rays.</p></li>
<li><p><strong>naz</strong> (<em>int</em>) – Approximate number of azimuthal angles uniformly spaced along the
outermost ring.  Each ring is constrained to have a multiple of 6
azimuths, so the realized value may be slightly different than
the input value here.  Inner rings will have fewer azimuths in
proportion to their radius, but will still be constrained to a
multiple of 6.  (If the innermost ring has radius 0, then exactly
1 ray, with azimuth undefined, will be used on that “ring”.)</p></li>
<li><p><strong>flux</strong> (<em>float, optional</em>) – Flux to assign each ray.  Default is 1.0.</p></li>
<li><p><strong>nrandom</strong> (<em>int, optional</em>) – If not None, then uniformly sample this many rays from annular
region instead of sampling on a hexapolar grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.asSpokes">
<em class="property">classmethod </em><code class="sig-name descname">asSpokes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optic</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backDist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">medium</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stopSurface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inner</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dirCos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">'postel'</span></em>, <em class="sig-param"><span class="n">spokes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rings</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">spacing</span><span class="o">=</span><span class="default_value">'uniform'</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.asSpokes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.asSpokes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RayVector on an annular region using a spokes pattern.</p>
<p>The function generates rays on a rings-and-spokes pattern, with a fixed
number of radii for each azimuth and a fixed number of azimuths for
each radius.  Its main use is for decomposing functions in pupil space
into Zernike components using Gaussian Quadrature integration on
annuli.  For more general purpose annular sampling, RayVector.asPolar()
is often a better choice since it samples the pupil more uniformly.</p>
<p>The algorithm used here starts by placing rays on the “stop” surface,
and then backing them up such that they are in front of any surfaces of
the optic they’re intended to trace.</p>
<p>The stop surface of most large telescopes is the plane perpendicular to
the optic axis and flush with the rim of the primary mirror.  This
plane is usually also the entrance pupil since there are no earlier
refractive or reflective surfaces.  However, since this plane is a bit
difficult to locate automatically, the default stop surface in batoid
is the global x-y plane.</p>
<p>If a telescope has a stopSurface attribute in its yaml file, then this
is usually a good choice to use in this function.  Using a curved
surface for the stop surface is allowed, but is usually a bad idea as
this may lead to a non-uniformly illuminated pupil and is inconsistent
with, say, an incoming uniform spherical wave or uniform plane wave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optic</strong> (<a class="reference internal" href="optic.html#batoid.Optic" title="batoid.Optic"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Optic</span></code></a>, optional) – If present, then try to extract values for <code class="docutils literal notranslate"><span class="pre">backDist</span></code>,
<code class="docutils literal notranslate"><span class="pre">medium</span></code>, <code class="docutils literal notranslate"><span class="pre">stopSurface</span></code>, and <code class="docutils literal notranslate"><span class="pre">outer</span></code> from the Optic.  Note
that values explicitly passed to <a class="reference internal" href="#batoid.RayVector.asSpokes" title="batoid.RayVector.asSpokes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">asSpokes</span></code></a> as keyword arguments
override those extracted from <code class="docutils literal notranslate"><span class="pre">optic</span></code>.</p></li>
<li><p><strong>backDist</strong> (<em>float, optional</em>) – Map rays backwards from the stop surface to the plane that is
perpendicular to the ray and <code class="docutils literal notranslate"><span class="pre">backDist</span></code> meters from the point
(0, 0, z(0,0)) on the stop surface.  This should generally be set
large enough that any obscurations or phantom surfaces occuring
before the stop surface are now “in front” of the ray.  If this
keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then
infer a value from <code class="docutils literal notranslate"><span class="pre">optic.backDist</span></code>.  If both this keyword and
<code class="docutils literal notranslate"><span class="pre">optic</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of 40 meters, which
should be sufficiently large for foreseeable telescopes.</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="media.html#batoid.Medium" title="batoid.Medium"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Medium</span></code></a>, optional) – Initial medium of each ray.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.inMedium</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of vacuum.</p></li>
<li><p><strong>stopSurface</strong> (<em>batoid.Interface, optional</em>) – Surface defining the system stop.  If this keyword is set to
<code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.stopSurface</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default <code class="docutils literal notranslate"><span class="pre">Interface(Plane())</span></code>, which is the
global x-y plane.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Vacuum wavelength of rays in meters.</p></li>
<li><p><strong>outer</strong> (<em>float</em>) – Outer radius of annulus in meters.</p></li>
<li><p><strong>inner</strong> (<em>float, optional</em>) – Inner radius of annulus in meters.  Default is 0.0.</p></li>
<li><p><strong>source</strong> (<em>None or ndarray of float, shape (3,), optional</em>) – Where rays originate.  If None, then rays originate an infinite
distance away, in which case the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg must also be
specified to set the direction of ray propagation.  If an ndarray,
then the rays originate from this point in global coordinates and
the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg is ignored.</p></li>
<li><p><strong>dirCos</strong> (<em>ndarray of float, shape (3,), optional</em>) – If source is None, then this indicates the initial direction of
propagation of the rays.  If source is not None, then this is
ignored.  Also see <code class="docutils literal notranslate"><span class="pre">theta_x</span></code>, <code class="docutils literal notranslate"><span class="pre">theta_y</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>theta_x, theta_y</strong> (<em>float, optional</em>) – Field angle in radians.  If source is None, then this indicates the
initial direction of propagation of the rays.  If source is not
None, then this is ignored.  Uses <a class="reference internal" href="coords.html#batoid.utils.fieldToDirCos" title="batoid.utils.fieldToDirCos"><code class="xref any py py-func docutils literal notranslate"><span class="pre">utils.fieldToDirCos</span></code></a> to convert
to direction cosines.  Also see <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>projection</strong> (<em>{‘postel’, ‘zemax’, ‘gnomonic’, ‘stereographic’, ‘lambert’, ‘orthographic’}, optional</em>) – Projection used to convert field angle to direction cosines.</p></li>
<li><p><strong>spokes</strong> (<em>int or ndarray of float</em>) – If int, then number of spokes to use.
If ndarray, then the values of the spokes azimuthal angles in
radians.</p></li>
<li><p><strong>rings</strong> (<em>int or ndarray of float</em>) – If int, then number of rings to use.
If array, then the values of the ring radii to use in meters.</p></li>
<li><p><strong>spacing</strong> (<em>{‘uniform’, ‘GQ’}</em>) – If uniform, assign ring radii uniformly between <code class="docutils literal notranslate"><span class="pre">inner</span></code> and
<code class="docutils literal notranslate"><span class="pre">outer</span></code>.
If GQ, then assign ring radii as the Gaussian Quadrature points
for integration on an annulus.  In this case, the ray fluxes will
be set to the Gaussian Quadrature weights (and the <code class="docutils literal notranslate"><span class="pre">flux</span></code> kwarg
will be ignored).</p></li>
<li><p><strong>flux</strong> (<em>float, optional</em>) – Flux to assign each ray.  Default is 1.0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.fromStop">
<em class="property">classmethod </em><code class="sig-name descname">fromStop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">optic</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backDist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">medium</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stopSurface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dirCos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">'postel'</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.fromStop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.fromStop" title="Permalink to this definition">¶</a></dt>
<dd><p>Create rays that intersects the “stop” surface at given points.</p>
<p>The algorithm used here starts by placing the rays on the “stop”
surface, and then backing them up such that they are in front of any
surfaces of the optic they’re intended to trace.</p>
<p>The stop surface of most large telescopes is the plane perpendicular to
the optic axis and flush with the rim of the primary mirror.  This
plane is usually also the entrance pupil since there are no earlier
refractive or reflective surfaces.  However, since this plane is a bit
difficult to locate automatically, the default stop surface in batoid
is the global x-y plane.</p>
<p>If a telescope has a stopSurface attribute in its yaml file, then this
is usually a good choice to use in this function.  Using a curved
surface for the stop surface is allowed, but is usually a bad idea as
this may lead to a non-uniformly illuminated pupil and is inconsistent
with, say, an incoming uniform spherical wave or uniform plane wave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x, y</strong> (<em>ndarray</em>) – X/Y coordinates on the stop surface where the rays would intersect
if not refracted or reflected first.</p></li>
<li><p><strong>optic</strong> (<a class="reference internal" href="optic.html#batoid.Optic" title="batoid.Optic"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Optic</span></code></a>, optional) – If present, then try to extract values for <code class="docutils literal notranslate"><span class="pre">backDist</span></code>,
<code class="docutils literal notranslate"><span class="pre">medium</span></code>, and <code class="docutils literal notranslate"><span class="pre">stopSurface</span></code> from the Optic.  Note that values
explicitly passed here as keyword arguments override those
extracted from <code class="docutils literal notranslate"><span class="pre">optic</span></code>.</p></li>
<li><p><strong>backDist</strong> (<em>float, optional</em>) – Map rays backwards from the stop surface to the plane that is
perpendicular to the rays and <code class="docutils literal notranslate"><span class="pre">backDist</span></code> meters from the point
(0, 0, z(0,0)) on the stop surface.  This should generally be set
large enough that any obscurations or phantom surfaces occuring
before the stop surface are now “in front” of the ray.  If this
keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then
infer a value from <code class="docutils literal notranslate"><span class="pre">optic.backDist</span></code>.  If both this keyword and
<code class="docutils literal notranslate"><span class="pre">optic</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of 40 meters, which
should be sufficiently large for foreseeable telescopes.</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="media.html#batoid.Medium" title="batoid.Medium"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Medium</span></code></a>, optional) – Initial medium of rays.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.inMedium</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of vacuum.</p></li>
<li><p><strong>stopSurface</strong> (<em>batoid.Interface, optional</em>) – Surface defining the system stop.  If this keyword is set to
<code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.stopSurface</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default <code class="docutils literal notranslate"><span class="pre">Interface(Plane())</span></code>, which is the
global x-y plane.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Vacuum wavelength of rays in meters.</p></li>
<li><p><strong>source</strong> (<em>None or ndarray of float, shape (3,), optional</em>) – Where the rays originate.  If None, then the rays originate an
infinite distance away, in which case the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg must also
be specified to set the direction of ray propagation.  If an
ndarray, then the rays originates from this point in global
coordinates and the <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> kwarg is ignored.</p></li>
<li><p><strong>dirCos</strong> (<em>ndarray of float, shape (3,), optional</em>) – If source is None, then indicates the direction of ray propagation.
If source is not None, then this is ignored.</p></li>
<li><p><strong>theta_x, theta_y</strong> (<em>float, optional</em>) – Field angle in radians.  If source is None, then this indicates the
initial direction of propagation of the rays.  If source is not
None, then this is ignored.  Uses <a class="reference internal" href="coords.html#batoid.utils.fieldToDirCos" title="batoid.utils.fieldToDirCos"><code class="xref any py py-func docutils literal notranslate"><span class="pre">utils.fieldToDirCos</span></code></a> to convert
to direction cosines.  Also see <code class="docutils literal notranslate"><span class="pre">dirCos</span></code> as an alternative to
this keyword.</p></li>
<li><p><strong>projection</strong> (<em>{‘postel’, ‘zemax’, ‘gnomonic’, ‘stereographic’, ‘lambert’, ‘orthographic’}, optional</em>) – Projection used to convert field angle to direction cosines.</p></li>
<li><p><strong>flux</strong> (<em>float, optional</em>) – Flux of rays.  Default is 1.0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.fromFieldAngles">
<em class="property">classmethod </em><code class="sig-name descname">fromFieldAngles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta_x</span></em>, <em class="sig-param"><span class="n">theta_y</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">'postel'</span></em>, <em class="sig-param"><span class="n">optic</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backDist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">medium</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stopSurface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wavelength</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.fromFieldAngles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.fromFieldAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RayVector with one stop surface point but many field angles.</p>
<p>This method is similar to <a class="reference internal" href="#batoid.RayVector.fromStop" title="batoid.RayVector.fromStop"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">fromStop</span></code></a> but broadcasts over <code class="docutils literal notranslate"><span class="pre">theta_x</span></code>
and <code class="docutils literal notranslate"><span class="pre">theta_y</span></code> instead of over <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.  There is less
currently less effort paid to synchronizing the <code class="docutils literal notranslate"><span class="pre">t</span></code> values of the
created rays, as they don’t correspond to points on a physical incoming
wavefront in this case.  The primary intended use case is to map chief
rays (<a href="#id1"><span class="problematic" id="id2">``</span></a>x``=``y``=0) from incoming field angle to focal plane position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta_x, theta_y</strong> (<em>ndarray</em>) – Field angles in radians.</p></li>
<li><p><strong>projection</strong> (<em>{‘postel’, ‘zemax’, ‘gnomonic’, ‘stereographic’, ‘lambert’, ‘orthographic’}, optional</em>) – Projection used to convert field angle to direction cosines.</p></li>
<li><p><strong>optic</strong> (<a class="reference internal" href="optic.html#batoid.Optic" title="batoid.Optic"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Optic</span></code></a>, optional) – If present, then try to extract values for <code class="docutils literal notranslate"><span class="pre">backDist</span></code>,
<code class="docutils literal notranslate"><span class="pre">medium</span></code>, and <code class="docutils literal notranslate"><span class="pre">stopSurface</span></code> from the Optic.  Note that values
explicitly passed here as keyword arguments override those
extracted from <code class="docutils literal notranslate"><span class="pre">optic</span></code>.</p></li>
<li><p><strong>backDist</strong> (<em>float, optional</em>) – Map rays backwards from the stop surface this far.  This should
generally be set large enough that any obscurations or phantom
surfaces occuring before the stop surface are now “in front” of the
rays.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword
is set, then infer a value from <code class="docutils literal notranslate"><span class="pre">optic.backDist</span></code>.  If both this
keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of 40 meters,
which should be sufficiently large for foreseeable telescopes.</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="media.html#batoid.Medium" title="batoid.Medium"><code class="xref any py py-class docutils literal notranslate"><span class="pre">batoid.Medium</span></code></a>, optional) – Initial medium of rays.  If this keyword is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.inMedium</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default of vacuum.</p></li>
<li><p><strong>stopSurface</strong> (<em>batoid.Interface, optional</em>) – Surface defining the system stop.  If this keyword is set to
<code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">optic</span></code> keyword is set, then infer a value from
<code class="docutils literal notranslate"><span class="pre">optic.stopSurface</span></code>.  If both this keyword and <code class="docutils literal notranslate"><span class="pre">optic</span></code> are
<code class="docutils literal notranslate"><span class="pre">None</span></code>, then use a default <code class="docutils literal notranslate"><span class="pre">Interface(Plane())</span></code>, which is the
global x-y plane.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Vacuum wavelength of rays in meters.</p></li>
<li><p><strong>x, y</strong> (<em>float</em>) – X/Y coordinates on the stop surface where the rays would intersect
if not refracted or reflected first.</p></li>
<li><p><strong>flux</strong> (<em>float, optional</em>) – Flux of rays.  Default is 1.0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.r">
<em class="property">property </em><code class="sig-name descname">r</code><a class="headerlink" href="#batoid.RayVector.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Positions of rays in meters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of float, shape (n, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#batoid.RayVector.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The x components of ray positions in meters.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#batoid.RayVector.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The y components of ray positions in meters.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.z">
<em class="property">property </em><code class="sig-name descname">z</code><a class="headerlink" href="#batoid.RayVector.z" title="Permalink to this definition">¶</a></dt>
<dd><p>The z components of ray positions in meters.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.v">
<em class="property">property </em><code class="sig-name descname">v</code><a class="headerlink" href="#batoid.RayVector.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocities of rays in units of the
speed of light in vacuum.  Note that these may have magnitudes &lt; 1 if
the rays are inside a refractive medium.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of float, shape (n, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.vx">
<em class="property">property </em><code class="sig-name descname">vx</code><a class="headerlink" href="#batoid.RayVector.vx" title="Permalink to this definition">¶</a></dt>
<dd><p>The x components of ray velocities units of the vacuum speed of
light.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.vy">
<em class="property">property </em><code class="sig-name descname">vy</code><a class="headerlink" href="#batoid.RayVector.vy" title="Permalink to this definition">¶</a></dt>
<dd><p>The y components of ray velocities units of the vacuum speed of
light.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.vz">
<em class="property">property </em><code class="sig-name descname">vz</code><a class="headerlink" href="#batoid.RayVector.vz" title="Permalink to this definition">¶</a></dt>
<dd><p>The z components of ray velocities units of the vacuum speed of
light.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.t">
<em class="property">property </em><code class="sig-name descname">t</code><a class="headerlink" href="#batoid.RayVector.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Reference times (divided by the speed of light in vacuum) in units
of meters, also known as the optical path lengths.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.wavelength">
<em class="property">property </em><code class="sig-name descname">wavelength</code><a class="headerlink" href="#batoid.RayVector.wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Vacuum wavelengths in meters.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.flux">
<em class="property">property </em><code class="sig-name descname">flux</code><a class="headerlink" href="#batoid.RayVector.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Fluxes in arbitrary units.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.vignetted">
<em class="property">property </em><code class="sig-name descname">vignetted</code><a class="headerlink" href="#batoid.RayVector.vignetted" title="Permalink to this definition">¶</a></dt>
<dd><p>True for rays that have been vignetted.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.failed">
<em class="property">property </em><code class="sig-name descname">failed</code><a class="headerlink" href="#batoid.RayVector.failed" title="Permalink to this definition">¶</a></dt>
<dd><p>True for rays that have failed.  This may occur, for example, if
batoid failed to find the intersection of a ray wiht a surface.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.k">
<em class="property">property </em><code class="sig-name descname">k</code><a class="headerlink" href="#batoid.RayVector.k" title="Permalink to this definition">¶</a></dt>
<dd><p>Wavevectors of plane waves in units
of radians per meter.  The magnitude of each wavevector is equal to
<span class="math notranslate nohighlight">\(2 \pi n / \lambda\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the refractive index and
<span class="math notranslate nohighlight">\(\lambda\)</span> is the wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of float, shape (n, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.kx">
<em class="property">property </em><code class="sig-name descname">kx</code><a class="headerlink" href="#batoid.RayVector.kx" title="Permalink to this definition">¶</a></dt>
<dd><p>The x component of each ray wavevector in radians per meter.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.ky">
<em class="property">property </em><code class="sig-name descname">ky</code><a class="headerlink" href="#batoid.RayVector.ky" title="Permalink to this definition">¶</a></dt>
<dd><p>The y component of each ray wavevector in radians per meter.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.kz">
<em class="property">property </em><code class="sig-name descname">kz</code><a class="headerlink" href="#batoid.RayVector.kz" title="Permalink to this definition">¶</a></dt>
<dd><p>The z component of each ray wavevector in radians per meter.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.omega">
<em class="property">property </em><code class="sig-name descname">omega</code><a class="headerlink" href="#batoid.RayVector.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>The temporal angular frequency of each plane wave divided by the
vacuum speed of light in units of radians per meter.  Equals
<span class="math notranslate nohighlight">\(2 \pi / \lambda\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="batoid.RayVector.toCoordSys">
<code class="sig-name descname">toCoordSys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coordSys</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/batoid/rayVector.html#RayVector.toCoordSys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#batoid.RayVector.toCoordSys" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform this RayVector into a new coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coordSys</strong> (<em>batoid.CoordSys</em>) – Destination coordinate system.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>RayVector</em> – Reference to self, no copy is made.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="surfaces.html" class="btn btn-neutral float-right" title="Surfaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="overview.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Josh Meyers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>